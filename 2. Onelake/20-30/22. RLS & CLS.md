# Topic 19: Row-Level and Column-Level Security (RLS/CLS)

*   **Row-Level Security (RLS)** and **Column-Level Security (CLS)** are fine-grained security features that restrict data access at the record and field level *within a single table*. They are the final and most granular layer of the security model in Microsoft Fabric, operating inside the database engine itself.
*   These features are essential for scenarios where different users or groups should see different slices of the same table. For example, a sales manager should only see the sales records for their own region, or an HR analyst should not be able to see the "Salary" column in an employee table.
*   In Microsoft Fabric, RLS and CLS are primarily implemented and enforced by the **SQL engine**. This means they are directly supported in **Fabric Data Warehouses** and for queries made through the **SQL analytics endpoint** of a Lakehouse. Power BI can also leverage these rules when connecting to a Warehouse or Lakehouse.

> [!IMPORTANT]
> A critical distinction to understand is that RLS and CLS, being SQL-based features, are **not natively enforced by Apache Spark**. A user with Contributor access who reads a table with a Spark Notebook in a Lakehouse will bypass the SQL RLS/CLS rules because they are reading the underlying Parquet files directly. Therefore, RLS/CLS in Fabric should be considered a robust security layer for the **consumption and analytics path (SQL and Power BI)**, not a blanket protection against developers with file-level access.

## **Core Components / Concepts**

### **Row-Level Security (RLS)**

*   **What it is:** A security mechanism that filters rows from a table based on the identity of the user executing the query. The filtering logic is implemented as a security policy on the table.
*   **How it Works:**
    1.  You create a **security predicate function**, which is an inline table-valued function (TVF) in T-SQL.
    2.  This function contains the logic that determines whether a user should see a given row. It typically filters based on a column in the table and compares it to the user's identity (e.g., `USER_NAME()` or `IS_MEMBER()`).
    3.  You then create a **security policy** that binds this predicate function to a specific table.
    4.  From that point on, whenever any user queries that table (even with `SELECT * FROM ...`), the SQL engine automatically and transparently applies the predicate function as a `WHERE` clause, silently filtering the results. The user is completely unaware that other rows even exist in the table.
*   **Analogy:** RLS is like giving every user a pair of magic glasses. When they look at a table, they only see the rows that have their name on them.

### **Column-Level Security (CLS)**

*   **What it is:** A much simpler mechanism that restricts users from seeing specific columns in a table.
*   **How it Works:**
    *   CLS is implemented using the standard T-SQL `GRANT` and `DENY` statements.
    *   By default, users have no access. You can `GRANT SELECT` permission on the entire table and then explicitly `DENY SELECT` on specific, sensitive columns to certain users or roles.
    *   When a user who is denied access to a column runs `SELECT *`, they will receive an error. If they select all other columns explicitly, the query will succeed.
*   **Analogy:** CLS is like taking a black marker and redacting certain columns on a report before handing it to a specific person.

## **Syntax & Implementation in Fabric**

*   RLS and CLS are defined using standard T-SQL syntax, which can be executed against a Fabric Data Warehouse or the SQL analytics endpoint of a Lakehouse.

### **Implementing Row-Level Security (RLS)**

*   **Scenario:** In a `FactSales` table, we want sales representatives to see only their own sales records. The table has a `Salesperson_UPN` column containing the user's principal name (e.g., `rep1@contoso.com`).

*   **Step 1: Create the Schema and Predicate Function**
    ```sql
    -- Create a separate schema for security objects (best practice)
    CREATE SCHEMA Security;
    GO

    -- Create the function. It returns a table with a single row (1) if the user should see the row.
    CREATE FUNCTION Security.fn_SalespersonPredicate(@Salesperson_UPN AS sysname)
        RETURNS TABLE
    WITH SCHEMABINDING
    AS
        RETURN SELECT 1 AS fn_PredicateResult
        WHERE @Salesperson_UPN = USER_NAME() OR IS_MEMBER('Sales Managers') = 1;
    GO
    ```
    *   `@Salesperson_UPN`: This is the input parameter that will receive the value from the `Salesperson_UPN` column for each row being evaluated.
    *   `USER_NAME()`: This is a built-in SQL function that returns the Entra ID UPN of the user executing the query.
    *   `IS_MEMBER('Sales Managers')`: This logic allows members of the 'Sales Managers' database role/Entra group to see all rows, bypassing the filter.

*   **Step 2: Create the Security Policy**
    ```sql
    -- Create the policy and bind the function to the FactSales table
    CREATE SECURITY POLICY Security.SalespersonFilter
    ADD FILTER PREDICATE Security.fn_SalespersonPredicate(Salesperson_UPN)
    ON dbo.FactSales
    WITH (STATE = ON);
    GO
    ```
    *   `ADD FILTER PREDICATE`: Specifies that this is an RLS policy that filters rows on read.
    *   `Security.fn_SalespersonPredicate(Salesperson_UPN)`: Binds the function and tells the engine to pass the value from the `Salesperson_UPN` column of the `FactSales` table into the function for each row.
    *   `STATE = ON`: Activates the policy.

### **Implementing Column-Level Security (CLS)**

*   **Scenario:** In an `DimEmployee` table, we want to prevent users in the `Junior_Analysts` role from seeing the `Salary` and `DateOfBirth` columns.

*   **Step 1: Create the Role and Add Members**
    ```sql
    CREATE ROLE Junior_Analysts;
    ALTER ROLE Junior_Analysts ADD MEMBER [analyst1@contoso.com];
    ```

*   **Step 2: Grant Table-Level Access**
    ```sql
    -- Give the role permission to select from the table in general
    GRANT SELECT ON dbo.DimEmployee TO Junior_Analysts;
    ```

*   **Step 3: Deny Column-Level Access**
    ```sql
    -- Explicitly deny access to the sensitive columns
    DENY SELECT ON dbo.DimEmployee(Salary) TO Junior_Analysts;
    DENY SELECT ON dbo.DimEmployee(DateOfBirth) TO Junior_Analysts;
    ```

*   **Result:**
    *   If `analyst1` runs `SELECT EmployeeName, Department FROM dbo.DimEmployee;`, the query succeeds.
    *   If `analyst1` runs `SELECT * FROM dbo.DimEmployee;` or `SELECT EmployeeName, Salary FROM dbo.DimEmployee;`, the query will fail with a permission error on the denied column.

## **Use Cases and Scenarios**

*   **### Multi-Tenant Applications**
    *   **Scenario:** A SaaS company uses a single Fabric Warehouse to store data for all of its customers. A `TenantId` column in every table identifies which customer the data belongs to.
    *   **Implementation:** An RLS policy can be implemented where the security predicate function filters every table `WHERE TenantId = SESSION_CONTEXT('TenantId')`. When a user from a specific customer logs into the application, the app sets the `TenantId` in the session context, and RLS automatically and securely ensures they can only ever see their own company's data.

*   **### Regional or Departmental Data Segregation**
    *   **Scenario:** A global company has a single `FactSales` table. The VP of North America should only see sales from the 'NA' region, while the VP of Europe should only see sales from 'EU'.
    *   **Implementation:** An RLS policy can use a lookup table that maps user UPNs to their allowed regions. The predicate function would join the `FactSales` table to this mapping table and filter the rows accordingly.

*   **### Compliance and PII Protection**
    *   **Scenario:** An HR table contains sensitive employee PII like social security numbers, salaries, and performance review scores. HR business partners need to see most of the data to do their jobs, but only senior HR managers should see the salary and review score columns.
    *   **Implementation:** This is a perfect combined use case.
        *   **RLS** can be used to ensure HR partners only see the records for employees in the departments they support.
        *   **CLS** can be used to deny the HR partners' role access to the `Salary` and `ReviewScore` columns, while granting it to the `HR_Managers` role.

## **Common Pitfalls / Mistakes**

*   **Mistake 1: Assuming RLS/CLS Protects Against Spark Access.**
    *   **Pitfall:** An admin implements RLS on a Lakehouse table via the SQL endpoint and assumes the data is fully protected. A data scientist with Contributor access to the workspace then reads the table with a Spark notebook and sees all the rows.
    *   **Correction:**
        > [!WARNING]
        > RLS and CLS are enforced by the **SQL engine only**. They do not apply to direct file access via Spark. To secure data from high-privilege workspace users (Contributors, Members, Admins), you must use workspace separation and OneLake Data Access Roles for Viewers. RLS/CLS is for securing the data consumption path for analysts and BI users.

*   **Mistake 2: Writing Overly Complex Predicate Functions.**
    *   **Pitfall:** A developer writes a complex RLS predicate function that involves multiple joins and complex `CASE` statements. Queries on the secured table become very slow.
    *   **Correction:** The security predicate function is executed for **every row** accessed by a query. It must be extremely fast and efficient. Avoid complex joins or calculations. A common best practice is to pre-calculate user permissions in a simple, optimized mapping table and have the function perform a simple lookup against that table.

*   **Mistake 3: Creating Side-Channel Leaks with RLS.**
    *   **Pitfall:** An RLS filter is designed to prevent a user from seeing specific rows. However, a user can infer the existence of hidden rows by exploiting errors. For example, if a `ProductId` is a primary key, and a user tries to `INSERT` a new row with a `ProductId` that already exists but is hidden from them by RLS, the query will fail on a primary key violation, thus leaking the information that the key exists.
    *   **Correction:** This is an advanced security consideration. For highly sensitive scenarios, you may need to use block predicates in RLS, which provide a more robust (but complex) level of protection against these "side-channel" attacks.

## **Flashcards (Q&A)**

*   **Q: What is the difference between Row-Level Security and Column-Level Security?**
    *   A: RLS filters which rows a user can see, while CLS restricts access to specific columns.
*   **Q: Which Fabric compute engine enforces RLS and CLS?**
    *   A: The SQL engine (in Data Warehouses and SQL analytics endpoints).
*   **Q: Does RLS/CLS prevent a user with Contributor access from seeing all the data via a Spark notebook?**
    *   A: No. Spark bypasses the SQL engine's security policies and reads the files directly.
*   **Q: What two T-SQL components are required to implement RLS?**
    *   A: A security predicate function (typically an inline TVF) and a security policy that binds the function to a table.
*   **Q: What T-SQL command is used to implement CLS?**
    *   A: The `DENY SELECT ON <table>(<column>) TO <role>` command.
*   **Q: What built-in SQL function is commonly used in an RLS predicate to get the current user's identity?**
    *   A: `USER_NAME()`.
*   **Q: A query on a table with an RLS policy is slow. What is the most likely cause?**
    *   A: The security predicate function is too complex and is taking a long time to execute for each row.
*   **Q: How does RLS work for the end user? Is it visible?**
    *   A: It is completely transparent. The user runs a normal query and simply sees a filtered subset of the data, unaware that other rows exist.
*   **Q: In which Fabric item can you implement a read/write RLS/CLS solution?**
    *   A: In a Fabric Data Warehouse. The Lakehouse SQL endpoint is read-only.
*   **Q: What is the primary use case for RLS in a multi-tenant SaaS application?**
    *   A: To ensure that users from one customer tenant can only see their own data and are securely isolated from all other tenants' data within a shared database.
